{"ast":null,"code":"// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function (root, factory) {\n  if ('function' === typeof define && define.amd != null) {\n    return define([], factory);\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function () {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n\n  escapeForRegex = function (string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n\n  concatMap = function (array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n\n    return results;\n  };\n\n  stringConcatMap = function (array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n\n    while (++i < length) {\n      result += f(array[i]);\n    }\n\n    return result;\n  };\n\n  regexGroupCount = function (regex) {\n    return new RegExp(regex.toString() + '|').exec('').length - 1;\n  };\n\n  keysAndValuesToObject = function (keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n\n      if (value == null) {\n        continue;\n      }\n\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n\n    return object;\n  };\n\n  P = {};\n\n  P.Result = function (value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n\n  P.Tagged = function (tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n\n  P.tag = function (tag, parser) {\n    return function (input) {\n      var result, tagged;\n      result = parser(input);\n\n      if (result == null) {\n        return;\n      }\n\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n\n  P.regex = function (regex) {\n    return function (input) {\n      var matches, result;\n      matches = regex.exec(input);\n\n      if (matches == null) {\n        return;\n      }\n\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n\n  P.sequence = function () {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function (input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n\n        if (result == null) {\n          return;\n        }\n\n        values.push(result.value);\n        rest = result.rest;\n      }\n\n      return new P.Result(values, rest);\n    };\n  };\n\n  P.pick = function () {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function (input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n\n      if (result == null) {\n        return;\n      }\n\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n\n  P.string = function (string) {\n    var length;\n    length = string.length;\n    return function (input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n\n  P.lazy = function (fn) {\n    var cached;\n    cached = null;\n    return function (input) {\n      if (cached == null) {\n        cached = fn();\n      }\n\n      return cached(input);\n    };\n  };\n\n  P.baseMany = function (parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n\n        if (endResult != null) {\n          break;\n        }\n      }\n\n      parserResult = parser(rest);\n\n      if (parserResult == null) {\n        break;\n      }\n\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n\n      rest = parserResult.rest;\n    }\n\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n\n    return new P.Result(results, rest);\n  };\n\n  P.many1 = function (parser) {\n    return function (input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n\n  P.concatMany1Till = function (parser, end) {\n    return function (input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n\n  P.firstChoice = function () {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function (input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n\n  newParser = function (options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function () {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function () {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function () {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function () {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function () {\n      return U.token;\n    }));\n    return U;\n  };\n\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n\n  baseAstNodeToRegexString = function (astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function (node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n\n      case 'static':\n        return escapeForRegex(astNode.value);\n\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n\n  astNodeToRegexString = function (astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n\n  astNodeToNames = function (astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n\n      case 'named':\n        return [astNode.value];\n\n      case 'static':\n        return [];\n\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n\n  getParam = function (params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n\n    value = params[key];\n\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n\n    result = Array.isArray(value) ? value[index] : value;\n\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n\n    return result;\n  };\n\n  astNodeContainsSegmentsForProvidedParams = function (astNode, params, nextIndexes) {\n    var i, length;\n\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n\n      case 'static':\n        return false;\n\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n\n  stringify = function (astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function (node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n\n      case 'static':\n        return astNode.value;\n\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n\n    }\n  };\n\n  UrlPattern = function (arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n\n    this.isRegex = arg1 instanceof RegExp;\n\n    if (!('string' === typeof arg1 || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n\n    if (this.isRegex) {\n      this.regex = arg1;\n\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n\n        groupCount = regexGroupCount(this.regex);\n\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n\n        this.names = arg2;\n      }\n\n      return;\n    }\n\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n\n  UrlPattern.prototype.match = function (url) {\n    var groups, match;\n    match = this.regex.exec(url);\n\n    if (match == null) {\n      return null;\n    }\n\n    groups = match.slice(1);\n\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n\n  UrlPattern.prototype.stringify = function (params) {\n    if (params == null) {\n      params = {};\n    }\n\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n\n    return stringify(this.ast, params, {});\n  };\n\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});","map":{"version":3,"sources":["E:/Git/Work/SynodalLegalDedartament3.0/my-app/node_modules/url-pattern/lib/url-pattern.js"],"names":["slice","root","factory","define","amd","exports","module","UrlPattern","P","astNodeContainsSegmentsForProvidedParams","astNodeToNames","astNodeToRegexString","baseAstNodeToRegexString","concatMap","defaultOptions","escapeForRegex","getParam","keysAndValuesToObject","newParser","regexGroupCount","stringConcatMap","stringify","string","replace","array","f","i","length","results","concat","result","regex","RegExp","toString","exec","keys","values","key","object","value","Array","isArray","push","Result","rest","Tagged","tag","parser","input","tagged","matches","sequence","parsers","arguments","call","pick","indexes","apply","lazy","fn","cached","baseMany","end","stringResult","atLeastOneResultRequired","endResult","parserResult","many1","concatMany1Till","firstChoice","options","U","wildcard","wildcardChar","optional","optionalSegmentStartChar","pattern","optionalSegmentEndChar","name","segmentNameCharset","named","segmentNameStartChar","escapedChar","escapeChar","token","segmentValueCharset","astNode","node","params","nextIndexes","sideEffects","index","maxIndex","Error","arg1","arg2","groupCount","parsed","withoutWhitespace","isRegex","ast","names","TypeError","prototype","match","url","groups","Object"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function(root, factory) {\n  if (('function' === typeof define) && (define.amd != null)) {\n    return define([], factory);\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function() {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n  escapeForRegex = function(string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n  concatMap = function(array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n    return results;\n  };\n  stringConcatMap = function(array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      result += f(array[i]);\n    }\n    return result;\n  };\n  regexGroupCount = function(regex) {\n    return (new RegExp(regex.toString() + '|')).exec('').length - 1;\n  };\n  keysAndValuesToObject = function(keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n      if (value == null) {\n        continue;\n      }\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n    return object;\n  };\n  P = {};\n  P.Result = function(value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n  P.Tagged = function(tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n  P.tag = function(tag, parser) {\n    return function(input) {\n      var result, tagged;\n      result = parser(input);\n      if (result == null) {\n        return;\n      }\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n  P.regex = function(regex) {\n    return function(input) {\n      var matches, result;\n      matches = regex.exec(input);\n      if (matches == null) {\n        return;\n      }\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n  P.sequence = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n        if (result == null) {\n          return;\n        }\n        values.push(result.value);\n        rest = result.rest;\n      }\n      return new P.Result(values, rest);\n    };\n  };\n  P.pick = function() {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function(input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n      if (result == null) {\n        return;\n      }\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n  P.string = function(string) {\n    var length;\n    length = string.length;\n    return function(input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n  P.lazy = function(fn) {\n    var cached;\n    cached = null;\n    return function(input) {\n      if (cached == null) {\n        cached = fn();\n      }\n      return cached(input);\n    };\n  };\n  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n        if (endResult != null) {\n          break;\n        }\n      }\n      parserResult = parser(rest);\n      if (parserResult == null) {\n        break;\n      }\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n      rest = parserResult.rest;\n    }\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n    return new P.Result(results, rest);\n  };\n  P.many1 = function(parser) {\n    return function(input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n  P.concatMany1Till = function(parser, end) {\n    return function(input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n  P.firstChoice = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n  newParser = function(options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function() {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function() {\n      return U.token;\n    }));\n    return U;\n  };\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n      case 'static':\n        return escapeForRegex(astNode.value);\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n  astNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n  astNodeToNames = function(astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n      case 'named':\n        return [astNode.value];\n      case 'static':\n        return [];\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n  getParam = function(params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n    value = params[key];\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    result = Array.isArray(value) ? value[index] : value;\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n    return result;\n  };\n  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {\n    var i, length;\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n      case 'static':\n        return false;\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n  stringify = function(astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n      case 'static':\n        return astNode.value;\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n    }\n  };\n  UrlPattern = function(arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n    this.isRegex = arg1 instanceof RegExp;\n    if (!(('string' === typeof arg1) || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n    if (this.isRegex) {\n      this.regex = arg1;\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n        groupCount = regexGroupCount(this.regex);\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n        this.names = arg2;\n      }\n      return;\n    }\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n  UrlPattern.prototype.match = function(url) {\n    var groups, match;\n    match = this.regex.exec(url);\n    if (match == null) {\n      return null;\n    }\n    groups = match.slice(1);\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n  UrlPattern.prototype.stringify = function(params) {\n    if (params == null) {\n      params = {};\n    }\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n    return stringify(this.ast, params, {});\n  };\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});\n"]},"metadata":{},"sourceType":"script"}